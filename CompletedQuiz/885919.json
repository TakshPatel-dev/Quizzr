{"0":{"id":922,"question":"What is the role of kube-apiserver and kube-scheduler?","description":null,"answers":{"answer_a":"The kube – apiserver follows the scale-out architecture and, is the front-end of the master node control panel.","answer_b":"The kube – apiserver follows the scale-out architecture and, is the back-end of the master node control panel.","answer_c":null,"answer_d":null,"answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"true","answer_b_correct":"false","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":null,"tip":null,"tags":[{"name":"Kubernetes"}],"category":"DevOps","difficulty":"Medium"},"1":{"id":1233,"question":"How do Liveness and Readiness Probes benefit applications in OpenShift?","description":"Liveness and Readiness Probes monitor application health, restarting pods if necessary to ensure availability.","answers":{"answer_a":"They allow the application to automatically scale down during low traffic","answer_b":"They manage application logging","answer_c":"They ensure the health and availability of pods by detecting issues and restarting pods if necessary","answer_d":"They encrypt application data in transit","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"false","answer_c_correct":"true","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Liveness and Readiness Probes help maintain application uptime by monitoring pod health and restarting when issues are detected.","tip":null,"tags":[{"name":"Openshift"}],"category":"DevOps","difficulty":"Medium"},"2":{"id":927,"question":"Which ones are a core Kubernetes object?","description":null,"answers":{"answer_a":"“Pods,” “Services,” “Volumes,”","answer_b":"“Swarm,” “Pilot,” “Node,”","answer_c":null,"answer_d":null,"answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"true","answer_b_correct":"false","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":null,"tip":null,"tags":[{"name":"Kubernetes"}],"category":"DevOps","difficulty":"Medium"},"3":{"id":10072,"question":"A team needs to validate infrastructure before deployment while catching errors early. Which approach would be most effective?","description":"Implementing robust validation for Terraform configurations.","answers":{"answer_a":"Review code visually before applying","answer_b":"Implement pre-commit hooks with input validation and policy checks","answer_c":"Try applying and roll back if there are problems","answer_d":"Run terraform validate only","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Pre-commit hooks with input validation and policy checks provide the most effective configuration validation. Pre-commit hooks run validation before code is committed to version control. Input validation ensures variables meet type and constraint requirements. Policy checks verify compliance with organizational standards. This approach catches errors before they enter version control, provides immediate feedback during development, prevents invalid configurations from being shared with the team, and creates a robust validation pipeline that identifies various categories of issues early in the development process.","tip":null,"tags":[{"name":"Terraform"}],"category":"DevOps","difficulty":"Medium"},"4":{"id":1427,"question":"How can you remove an unused Docker image from your system?","description":"Removing unused images frees up space on the local machine.","answers":{"answer_a":"docker rm <image_id>","answer_b":"docker rmi <image_id>","answer_c":"docker delete <image_id>","answer_d":"docker remove <image_id>","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"The `docker rmi <image_id>` command removes a Docker image from the local machine.","tip":null,"tags":[{"name":"Docker"}],"category":"DevOps","difficulty":"Medium"},"5":{"id":10114,"question":"A team needs to implement infrastructure monitoring for their Terraform-managed resources. Which approach would be most comprehensive?","description":"Implementing effective infrastructure monitoring with Terraform.","answers":{"answer_a":"Check the cloud provider console periodically","answer_b":"Implement automated monitoring with threshold-based alerts and dashboards","answer_c":"React to issues when users report them","answer_d":"Focus only on cost monitoring","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Automated monitoring with threshold-based alerts and dashboards provides the most comprehensive monitoring solution. Automated monitoring continually checks infrastructure health. Threshold-based alerts notify teams before issues impact users. Dashboards provide visibility into infrastructure status. This approach enables proactive detection of issues before they affect users, provides comprehensive visibility into infrastructure performance and health, automates appropriate responses to common issues, centralizes monitoring across all infrastructure components, and creates a complete monitoring system that ensures infrastructure reliability.","tip":null,"tags":[{"name":"Terraform"}],"category":"DevOps","difficulty":"Medium"},"6":{"id":10136,"question":"A team is experiencing slow Docker build times for their application. Which approach would most effectively improve build performance?","description":"Optimizing Docker build performance.","answers":{"answer_a":"Add more resources to the build machine","answer_b":"Implement layer caching strategies and build context optimization","answer_c":"Use the --no-cache flag for all builds","answer_d":"Build images only in production","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Layer caching strategies and build context optimization directly address the causes of slow builds. Layer caching strategies (ordering Dockerfile instructions to maximize cache usage, grouping infrequently changed content) leverage Docker's layer system to avoid redundant work. Build context optimization (using .dockerignore files, minimizing the build context size) reduces the amount of data sent to the Docker daemon. This approach significantly reduces build times by eliminating unnecessary processing and file transfers, creating consistently fast builds across environments while maintaining the same resulting image quality.","tip":null,"tags":[{"name":"Docker"}],"category":"DevOps","difficulty":"Medium"},"7":{"id":10062,"question":"A team needs to ensure their Terraform code meets company security and compliance standards. Which approach would be most effective?","description":"Implementing policy enforcement for Terraform.","answers":{"answer_a":"Manual code review by security team","answer_b":"Implement policy-as-code with Sentinel or OPA and CI/CD integration","answer_c":"Add comments explaining security requirements","answer_d":"Use only pre-approved modules","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Policy-as-code with Sentinel or Open Policy Agent (OPA) and CI/CD integration provides the most effective compliance enforcement. Policy-as-code defines security and compliance requirements as executable code. CI/CD integration automatically validates all infrastructure changes against policies before applying. This approach ensures consistent policy enforcement across all deployments, provides immediate feedback to developers about policy violations, prevents non-compliant infrastructure from being deployed, and creates a scalable compliance system that automatically adapts as policies evolve.","tip":null,"tags":[{"name":"Terraform"}],"category":"DevOps","difficulty":"Medium"},"8":{"id":905,"question":"Which of the K8s resources do not associate with any namespace?","description":null,"answers":{"answer_a":"DaemonSets","answer_b":"Persistent Volumes","answer_c":"ReplicaSets","answer_d":"Nodes","answer_e":"Services","answer_f":null},"multiple_correct_answers":"true","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"true","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":null,"tip":null,"tags":[{"name":"Kubernetes"}],"category":"DevOps","difficulty":"Medium"},"9":{"id":10130,"question":"A team needs to ensure that their containerized application can handle graceful shutdowns. Which implementation would be most effective?","description":"Implementing graceful shutdown handling in Docker containers.","answers":{"answer_a":"Kill containers immediately when they need to be stopped","answer_b":"Implement proper signal handling with a suitable init process","answer_c":"Restart containers automatically when they stop","answer_d":"Use the --force flag when stopping containers","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Proper signal handling with a suitable init process ensures graceful container shutdown. Signal handling in the application code captures SIGTERM signals from Docker and initiates graceful shutdown procedures like completing in-flight requests and closing database connections. A suitable init process (like tini or dumb-init) correctly forwards signals to the application and handles process reaping. This approach prevents data corruption, transaction interruption, and connection leaks during container termination, while enabling seamless rolling updates and scaling operations without service disruption.","tip":null,"tags":[{"name":"Docker"}],"category":"DevOps","difficulty":"Medium"},"quizMetaData":{"createdBy":"99692866465","difficulty":"medium","topic":"devops","totalQuestions":"10","createdAt":"25/05/2025\t15:42:30","description":"vcbvcb","time":"30"},"marks":"0","answer":{}}