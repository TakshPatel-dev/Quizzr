{"0":{"id":2291,"question":"Which PostgreSQL configuration would you modify to optimize memory usage for sort operations?","description":"Understanding memory configuration for sort operations in PostgreSQL.","answers":{"answer_a":"shared_buffers","answer_b":"work_mem","answer_c":"effective_cache_size","answer_d":"maintenance_work_mem","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"work_mem determines the memory allocated for sort operations and hash tables per operation. Increasing it can improve the performance of ORDER BY and GROUP BY operations by reducing disk writes.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"1":{"id":2277,"question":"What is the purpose of the EXPLAIN ANALYZE command in PostgreSQL?","description":"Understanding query performance analysis tools in PostgreSQL.","answers":{"answer_a":"It only shows the theoretical execution plan","answer_b":"It executes the query and shows actual timing and row counts along with the plan","answer_c":"It analyzes table statistics without running the query","answer_d":"It only shows query syntax errors","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"EXPLAIN ANALYZE actually executes the query and provides both the execution plan and real-world performance metrics, including actual time spent on each operation and actual row counts. This makes it invaluable for query optimization.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"2":{"id":2272,"question":"What is the purpose of a MATERIALIZED VIEW in PostgreSQL?","description":"Understanding view optimization techniques.","answers":{"answer_a":"To create a virtual table that updates automatically","answer_b":"To store the result of a query physically and refresh it manually","answer_c":"To create a temporary table that gets deleted on session end","answer_d":"To create a view that only authorized users can access","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"A MATERIALIZED VIEW stores the results of a query physically, allowing faster access to complex query results at the cost of manual updates. This is particularly useful for complex queries that don't need real-time results.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"3":{"id":2305,"question":"What is the most efficient way to handle temporary data in PostgreSQL?","description":"Understanding temporary data management in PostgreSQL.","answers":{"answer_a":"Create regular tables and delete data","answer_b":"Use TEMPORARY tables with ON COMMIT DROP","answer_c":"Store in memory only","answer_d":"Use materialized views","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"TEMPORARY tables with ON COMMIT DROP provide efficient handling of session-specific temporary data, automatically cleaning up resources when the transaction ends.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"4":{"id":2334,"question":"Which approach provides the most efficient solution for finding duplicate records across multiple columns?","description":"Understanding data quality management in PostgreSQL.","answers":{"answer_a":"Multiple individual queries","answer_b":"GROUP BY with HAVING count(*) > 1","answer_c":"Self-join","answer_d":"Cursor-based approach","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Using GROUP BY with HAVING count(*) > 1 provides the most efficient way to identify duplicates across multiple columns, especially when combined with appropriate indexes.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"5":{"id":2274,"question":"Which PostgreSQL feature would you use to ensure that when a user is deleted, all their related records in other tables are automatically deleted?","description":"Understanding referential integrity in PostgreSQL.","answers":{"answer_a":"CASCADE trigger","answer_b":"ON DELETE CASCADE in foreign key constraint","answer_c":"Stored procedure","answer_d":"Application-level deletion","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"ON DELETE CASCADE in the foreign key constraint is the most efficient and reliable way to automatically delete related records. It's handled at the database level, ensuring referential integrity is maintained regardless of how the deletion is performed.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"6":{"id":2386,"question":"What is the most efficient way to handle non-selective column filtering in large tables?","description":"Understanding scan optimization.","answers":{"answer_a":"Create additional indexes","answer_b":"Use BRIN indexes with appropriate pages_per_range","answer_c":"Full table scan","answer_d":"Partial indexes","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"BRIN indexes with appropriate pages_per_range provide efficient filtering for non-selective columns by maintaining minimal index size while enabling block-level pruning.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"7":{"id":2387,"question":"Which approach best optimizes performance for frequent INSERT...RETURNING operations?","description":"Understanding insert optimization.","answers":{"answer_a":"Use triggers","answer_b":"Minimize indexes and use UNLOGGED tables where appropriate","answer_c":"Batch inserts","answer_d":"Use sequences","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Minimizing indexes and using UNLOGGED tables where appropriate reduces write overhead for INSERT...RETURNING operations while maintaining necessary return value functionality.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"8":{"id":2365,"question":"Which technique most effectively improves performance of repeated complex queries?","description":"Understanding query result optimization.","answers":{"answer_a":"Create regular views","answer_b":"Use materialized views with concurrent refresh","answer_c":"Use temporary tables","answer_d":"Cache in application","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Materialized views with concurrent refresh provide fast access to complex query results while allowing updates without blocking reads, ideal for frequently accessed computed data.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"9":{"id":2296,"question":"Which monitoring metric best indicates potential performance issues in PostgreSQL?","description":"Understanding PostgreSQL performance monitoring.","answers":{"answer_a":"Number of active connections","answer_b":"Transaction ID wraparound","answer_c":"Cache hit ratio","answer_d":"Number of dead tuples","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"false","answer_c_correct":"true","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Cache hit ratio indicates how often data is found in PostgreSQL's buffer cache vs. reading from disk. A low ratio suggests potential memory configuration issues or inefficient queries.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"quizMetaData":{"createdBy":"99692866465","difficulty":"medium","topic":"postgres","totalQuestions":"10","createdAt":"25/05/2025\t15:25:45","description":"dfgbvbvb","time":"30"},"marks":"0","answer":{"0":"answer_a"}}