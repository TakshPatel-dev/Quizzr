{"0":{"id":2380,"question":"Which technique most effectively improves performance of full text search on large text columns?","description":"Understanding text search optimization.","answers":{"answer_a":"B-tree index on text column","answer_b":"GIN index on tsvector with column pre-processing","answer_c":"GIST index","answer_d":"Expression index","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"GIN index on pre-processed tsvector columns provides efficient full text search by indexing all tokens while column pre-processing reduces runtime overhead.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"1":{"id":2316,"question":"How can you implement fuzzy string matching in PostgreSQL?","description":"Understanding text search capabilities in PostgreSQL.","answers":{"answer_a":"Using LIKE operator","answer_b":"Using pg_trgm extension with similarity functions","answer_c":"Using regular expressions","answer_d":"Using full-text search","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"The pg_trgm extension provides functions for similarity matching and indexing support for fuzzy string searches, making it efficient for finding similar strings or implementing 'did you mean' functionality.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"2":{"id":2369,"question":"What is the most effective way to optimize LIKE queries with wildcards?","description":"Understanding pattern matching optimization.","answers":{"answer_a":"B-tree index","answer_b":"GiST index with pg_trgm","answer_c":"Expression index","answer_d":"Hash index","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"GiST index with pg_trgm extension provides efficient pattern matching for LIKE queries with wildcards, especially for leading wildcard searches that B-tree indexes can't handle.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"3":{"id":2334,"question":"Which approach provides the most efficient solution for finding duplicate records across multiple columns?","description":"Understanding data quality management in PostgreSQL.","answers":{"answer_a":"Multiple individual queries","answer_b":"GROUP BY with HAVING count(*) > 1","answer_c":"Self-join","answer_d":"Cursor-based approach","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Using GROUP BY with HAVING count(*) > 1 provides the most efficient way to identify duplicates across multiple columns, especially when combined with appropriate indexes.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"4":{"id":2415,"question":"Which approach provides the best performance for multi-column pattern matching queries?","description":"Understanding pattern matching optimization.","answers":{"answer_a":"Multiple LIKE conditions","answer_b":"GiST index with composite trigram operators","answer_c":"Regular expressions","answer_d":"Full text search","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"GiST index with composite trigram operators provides efficient multi-column pattern matching by enabling index-based similarity searches across multiple columns.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"5":{"id":2297,"question":"What is the best practice for managing sequence gaps in PostgreSQL?","description":"Understanding sequence management in PostgreSQL.","answers":{"answer_a":"Reset sequences regularly","answer_b":"Accept gaps as normal and unavoidable","answer_c":"Use triggers to fill gaps","answer_d":"Switch to UUID","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Sequence gaps are normal and attempting to prevent them can lead to serious performance and concurrency issues. They should be accepted as a trade-off for performance and reliability.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"6":{"id":2296,"question":"Which monitoring metric best indicates potential performance issues in PostgreSQL?","description":"Understanding PostgreSQL performance monitoring.","answers":{"answer_a":"Number of active connections","answer_b":"Transaction ID wraparound","answer_c":"Cache hit ratio","answer_d":"Number of dead tuples","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"false","answer_c_correct":"true","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Cache hit ratio indicates how often data is found in PostgreSQL's buffer cache vs. reading from disk. A low ratio suggests potential memory configuration issues or inefficient queries.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"7":{"id":2384,"question":"What is the most effective way to optimize DISTINCT operations on large result sets?","description":"Understanding DISTINCT optimization.","answers":{"answer_a":"Increase work_mem","answer_b":"Use indexed columns with WHERE clause","answer_c":"Convert to GROUP BY","answer_d":"Use temporary tables","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Using indexed columns with a WHERE clause reduces the dataset before DISTINCT processing, improving performance by minimizing the amount of data that needs to be deduplicated.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"8":{"id":2266,"question":"What is the primary advantage of using JSONB over JSON data type in PostgreSQL?","description":"Understanding PostgreSQL's JSON storage options and their performance implications.","answers":{"answer_a":"JSONB takes less storage space than JSON","answer_b":"JSONB is stored in a decomposed binary format that allows faster queries and indexing","answer_c":"JSONB maintains the exact formatting of the input JSON","answer_d":"JSONB automatically validates JSON schema","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"JSONB stores data in a decomposed binary format, which eliminates the need to reparse the JSON on each query. This allows for faster query processing and enables indexing on JSON fields, making it more efficient for querying and searching JSON data.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"9":{"id":2294,"question":"How would you efficiently track row changes in a PostgreSQL table for audit purposes?","description":"Understanding audit logging in PostgreSQL.","answers":{"answer_a":"Create triggers for INSERT, UPDATE, DELETE","answer_b":"Use temporal tables with system_versioning","answer_c":"Enable logical decoding","answer_d":"Query the WAL logs","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"true","answer_b_correct":"false","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Triggers for INSERT, UPDATE, and DELETE operations provide a reliable way to track changes with minimal performance impact, allowing custom audit data capture and flexible audit trail management.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Medium"},"quizMetaData":{"createdBy":"99692866465","difficulty":"medium","topic":"postgres","totalQuestions":"10","createdAt":"25/05/2025\t01:34:29","description":"qrfdgd","time":"30"},"marks":"0","answer":{"0":"answer_d","1":"answer_c","2":"answer_a"}}