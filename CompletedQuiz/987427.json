{"0":{"id":2347,"question":"What is the most effective way to implement custom aggregate functions with multiple input columns in PostgreSQL?","description":"Understanding custom aggregates in PostgreSQL.","answers":{"answer_a":"Multiple separate aggregates","answer_b":"Custom aggregate with composite transition type","answer_c":"String concatenation","answer_d":"JSON aggregation","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Custom aggregates with composite transition types allow efficient processing of multiple input columns in a single pass, providing better performance than multiple separate aggregations.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"1":{"id":2322,"question":"Which PostgreSQL feature would you use to enforce constraints across multiple rows?","description":"Understanding advanced constraint management in PostgreSQL.","answers":{"answer_a":"Regular CHECK constraints","answer_b":"Exclusion constraints with custom operators","answer_c":"Foreign keys","answer_d":"Unique constraints","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Exclusion constraints with custom operators allow you to enforce complex rules involving multiple rows, such as preventing overlapping time ranges or ensuring spatial non-intersection.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"2":{"id":2287,"question":"Which PostgreSQL feature would you use to ensure referential integrity across multiple databases?","description":"Understanding distributed database management in PostgreSQL.","answers":{"answer_a":"Foreign Data Wrappers with triggers","answer_b":"Regular foreign keys","answer_c":"Application-level checks","answer_d":"Stored procedures","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"true","answer_b_correct":"false","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Foreign Data Wrappers combined with triggers provide a way to maintain referential integrity across multiple databases by allowing you to access and validate foreign data while enforcing constraints through trigger mechanisms.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"3":{"id":2429,"question":"What is the most effective approach for handling high-frequency counter updates across multiple tables?","description":"Understanding distributed counter optimization.","answers":{"answer_a":"Single counter table","answer_b":"Sharded counters with periodic aggregation","answer_c":"Regular updates","answer_d":"In-memory counting","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Sharded counters with periodic aggregation provide efficient high-frequency counting by distributing write load and reducing contention while maintaining eventual consistency.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"4":{"id":2337,"question":"Which PostgreSQL feature best handles automatic data partitioning based on insert values?","description":"Understanding declarative partitioning in PostgreSQL.","answers":{"answer_a":"Manual table creation","answer_b":"Declarative partitioning with partition bounds","answer_c":"Triggers for routing","answer_d":"Views with rules","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Declarative partitioning with defined partition bounds automatically routes inserted rows to appropriate partitions without the overhead of triggers or manual routing logic.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"5":{"id":2332,"question":"How would you optimize PostgreSQL for handling numerous small transactions?","description":"Understanding transaction optimization in PostgreSQL.","answers":{"answer_a":"Increase shared_buffers","answer_b":"Use synchronous_commit = off when appropriate","answer_c":"Disable WAL","answer_d":"Use unlogged tables","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Setting synchronous_commit = off can significantly improve performance for numerous small transactions when immediate durability isn't required, while still maintaining data integrity.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"6":{"id":2414,"question":"What is the most effective way to handle high-throughput upserts with conflict resolution?","description":"Understanding high-throughput write optimization.","answers":{"answer_a":"Individual upserts","answer_b":"Batch upserts with deferred constraints and conflict resolution functions","answer_c":"Separate insert/update","answer_d":"Use triggers","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Batch upserts with deferred constraints and conflict resolution functions provide efficient high-throughput writes by reducing lock contention and handling conflicts systematically.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"7":{"id":2435,"question":"What is the most efficient approach for handling concurrent aggregate updates in materialized views?","description":"Understanding concurrent aggregation optimization.","answers":{"answer_a":"Lock-based updates","answer_b":"Delta tables with MVCC-based merging","answer_c":"Complete refresh","answer_d":"Trigger-based updates","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Delta tables with MVCC-based merging provide efficient concurrent aggregate updates by maintaining changes separately and merging them consistently without blocking reads.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"8":{"id":2360,"question":"What is the most efficient way to handle vacuum on tables with frequent updates?","description":"Understanding vacuum optimization.","answers":{"answer_a":"Manual VACUUM FULL regularly","answer_b":"Autovacuum with table-specific thresholds","answer_c":"Disable autovacuum","answer_d":"Daily maintenance window","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Setting table-specific autovacuum thresholds allows for more frequent vacuum operations on heavily updated tables while avoiding unnecessary work on stable tables.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"9":{"id":2460,"question":"Which approach provides the best performance for maintaining materialized aggregates with high update frequency?","description":"Understanding aggregate maintenance optimization.","answers":{"answer_a":"Complete recalculation","answer_b":"Incremental updates with delta tables and background merging","answer_c":"Regular views","answer_d":"Trigger-based updates","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Incremental updates with delta tables and background merging provide efficient aggregate maintenance by minimizing update overhead while maintaining consistency through controlled merging.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"10":{"id":2444,"question":"What is the most effective way to handle frequent updates to nested JSON structures?","description":"Understanding JSON update optimization.","answers":{"answer_a":"Complete document updates","answer_b":"Jsonb_set with path-specific updates and partial indexing","answer_c":"Store as separate columns","answer_d":"Use regular JSON","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Jsonb_set with path-specific updates and partial indexing provides efficient nested JSON updates by modifying only changed paths and maintaining relevant index entries.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"11":{"id":2348,"question":"How can you implement efficient full-text search across multiple languages with different alphabets in PostgreSQL?","description":"Understanding multilingual search implementation in PostgreSQL.","answers":{"answer_a":"Multiple LIKE queries","answer_b":"Multiple tsvector columns with appropriate dictionaries","answer_c":"Regular expressions","answer_d":"External search engine","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Multiple tsvector columns with appropriate dictionaries for each language provide efficient multilingual full-text search while respecting language-specific rules and alphabets.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"12":{"id":2373,"question":"What is the most effective strategy for optimizing WHERE conditions on JSON/JSONB columns?","description":"Understanding JSON query optimization.","answers":{"answer_a":"Full table scan","answer_b":"GIN index on specific JSON paths","answer_c":"Convert to regular columns","answer_d":"Expression index","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"GIN indexes on specific JSON paths provide efficient querying of JSON/JSONB columns by creating searchable index entries for frequently accessed paths.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"13":{"id":2331,"question":"What is the best practice for handling dynamic SQL in PostgreSQL stored procedures?","description":"Understanding dynamic SQL best practices in PostgreSQL.","answers":{"answer_a":"String concatenation","answer_b":"EXECUTE format() with parameters","answer_c":"Using views","answer_d":"Multiple stored procedures","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Using EXECUTE with format() and parameters provides safe dynamic SQL execution while preventing SQL injection and maintaining query plan caching capabilities.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"14":{"id":2284,"question":"What is the purpose of CLUSTER command in PostgreSQL?","description":"Understanding physical data organization in PostgreSQL.","answers":{"answer_a":"To group similar queries together","answer_b":"To physically reorder table data based on an index","answer_c":"To create table groups","answer_d":"To organize tables by schema","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"The CLUSTER command physically reorders table data to match the order of an index, which can improve performance for queries that access data in index order by reducing disk I/O.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"15":{"id":2343,"question":"What is the most effective way to handle versioning of JSON documents in PostgreSQL?","description":"Understanding JSON data versioning in PostgreSQL.","answers":{"answer_a":"Store multiple copies","answer_b":"Use JSONB operators with temporal tables","answer_c":"External version control","answer_d":"Separate version table","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Using JSONB operators with temporal tables provides efficient versioning of JSON documents while maintaining queryability and historical tracking capabilities.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"16":{"id":2289,"question":"What is the most efficient way to implement a queue system in PostgreSQL?","description":"Understanding queue implementation patterns in PostgreSQL.","answers":{"answer_a":"Using timestamps and polling","answer_b":"Using SKIP LOCKED with FOR UPDATE","answer_c":"Using advisory locks","answer_d":"Using sequences","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Using SELECT FOR UPDATE SKIP LOCKED provides the most efficient queue implementation as it allows concurrent dequeuing without blocking, perfect for worker processes consuming queue items in parallel.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"17":{"id":2362,"question":"What is the most effective method to optimize partitioned table performance?","description":"Understanding partition optimization.","answers":{"answer_a":"Create more partitions","answer_b":"Enable partition pruning with appropriate constraints","answer_c":"Use smaller partitions","answer_d":"Merge partitions","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Enabling partition pruning with well-designed constraints allows the query planner to skip irrelevant partitions, significantly improving query performance.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"18":{"id":2329,"question":"What is the most efficient way to implement a search-as-you-type feature in PostgreSQL?","description":"Understanding text search optimization in PostgreSQL.","answers":{"answer_a":"Use LIKE with wildcards","answer_b":"Create trigram indexes with pg_trgm","answer_c":"Full-text search with tsvector","answer_d":"Regular expressions","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Trigram indexes with pg_trgm provide efficient partial string matching suitable for search-as-you-type functionality, with better performance than LIKE or regular expressions.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"19":{"id":2370,"question":"Which approach provides the best performance for calculating running totals in real-time?","description":"Understanding window function optimization.","answers":{"answer_a":"Subqueries","answer_b":"Window functions with materialized incremental aggregates","answer_c":"Recursive CTE","answer_d":"Self-join","answer_e":null,"answer_f":null},"multiple_correct_answers":"false","correct_answers":{"answer_a_correct":"false","answer_b_correct":"true","answer_c_correct":"false","answer_d_correct":"false","answer_e_correct":"false","answer_f_correct":"false"},"correct_answer":null,"explanation":"Window functions combined with materialized incremental aggregates provide efficient real-time running totals by maintaining partial results and minimizing recalculation.","tip":null,"tags":[{"name":"Postgres"}],"category":"Postgres","difficulty":"Hard"},"quizMetaData":{"createdBy":"18656047691","difficulty":"hard","topic":"postgres","totalQuestions":"20","createdAt":"09/05/2025\t11:49:22","description":"Postres Quiz","time":"60"},"marks":"6","answer":{"0":"answer_a","1":"answer_c","2":"answer_a","4":"answer_c","5":"answer_b","6":"answer_c","7":"answer_b","8":"answer_b","9":"answer_d","10":"answer_a","11":"answer_a","12":"answer_b","13":"answer_b","14":"answer_a","15":"answer_a","16":"answer_c","17":"answer_d","18":"answer_a","19":"answer_a"}}